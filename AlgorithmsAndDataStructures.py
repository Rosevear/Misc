import doctest
<<<<<<< HEAD
import math
=======
>>>>>>> 065814e8b6dfd54a9fe3d6ee12331e28e75be793
import random

###ALGORITHMS###
    

###Sorting Algorithms###

def bubble_sort(listx):
    """
    list of num -> list of num

    sort listx from lowest to highest

    >>> x = [15, 76, 56, 3, 14, 21, 19, 0] 
    >>> bubble_sort(x)
    [0, 3, 14, 15, 19, 21, 56, 76]
    >>> y = [1]
    >>> bubble_sort(y)
    [1]
    >>> z = [1, 2, 3, 4, 5]
    >>> bubble_sort(z)
    [1, 2, 3, 4, 5]
    >>> a = [2, 1]
    >>> bubble_sort(a)
    [1, 2]
    >>> b = [5, 4, 3, 2, 1]
    >>> bubble_sort(b)
    [1, 2, 3, 4, 5]
    """
    
    unsorted_marker = 0 #Sorted up to but NOT including this variable value.
    for i in range(len(listx)):
        for j in range(0, (len(listx)- unsorted_marker) - 1):
            if listx[j] > listx[j + 1]:
                temp = listx[j]
                listx[j] = listx[j + 1]
                listx[j + 1] = temp
        unsorted_marker = unsorted_marker + 1
    return listx

def selection_sort(listx):
    """
    list of num -> list of num

    sort listx from lowest to highest

    >>> x = [15, 76, 56, 3, 14, 21, 19, 0] 
    >>> selection_sort(x)
    [0, 3, 14, 15, 19, 21, 56, 76]
    >>> y = [1]
    >>> selection_sort(y)
    [1]
    >>> z = [1, 2, 3, 4, 5]
    >>> selection_sort(z)
    [1, 2, 3, 4, 5]
    >>> a = [2, 1]
    >>> selection_sort(a)
    [1, 2]
    >>> b = [5, 4, 3, 2, 1]
    >>> selection_sort(b)
    [1, 2, 3, 4, 5]
    """
    unsorted_marker = 0
    for i in range(len(listx)):
        current_smallest_element = listx[unsorted_marker]
        smallest_element_index = unsorted_marker
        for j in range(unsorted_marker, len(listx)):
            if listx[j] < current_smallest_element:
                current_smallest_element = listx[j]
                smallest_element_index = j
        listx[smallest_element_index] = listx[unsorted_marker]
        listx[unsorted_marker] = current_smallest_element
        unsorted_marker = unsorted_marker + 1
    return listx

def insertion_sort(listx):
    """
    list of num -> list of num

    sort listx from lowest to highest

    >>> x = [15, 76, 56, 3, 14, 21, 19, 0] 
    >>> insertion_sort(x)
    [0, 3, 14, 15, 19, 21, 56, 76]
    >>> y = [1]
    >>> insertion_sort(y)
    [1]
    >>> z = [1, 2, 3, 4, 5]
    >>> insertion_sort(z)
    [1, 2, 3, 4, 5]
    >>> a = [2, 1]
    >>> insertion_sort(a)
    [1, 2]
    >>> b = [5, 4, 3, 2, 1]
    >>> insertion_sort(b)
    [1, 2, 3, 4, 5]
    """

    for i in range(1, len(listx)):
        current_value = listx[i]
        current_position = i
        while current_value < listx[current_position - 1] and current_position > 0:
            listx[current_position] = listx[current_position - 1]
            current_position = current_position - 1
        listx[current_position] = current_value
    return listx


def shell_sort(listx): # Using for the gap sequence all values of (2 ** k) - 1, such that they are < len(listx).
    """
    list of num -> list of num

    sort listx from lowest to highest

    >>> x = [15, 76, 56, 3, 14, 21, 19, 0] 
    >>> shell_sort(x)
    [0, 3, 14, 15, 19, 21, 56, 76]
    >>> y = [1]
    >>> shell_sort(y)
    [1]
    >>> z = [1, 2, 3, 4, 5]
    >>> shell_sort(z)
    [1, 2, 3, 4, 5]
    >>> a = [2, 1]
    >>> shell_sort(a)
    [1, 2]
    >>> b = [5, 4, 3, 2, 1]
    >>> shell_sort(b)
    [1, 2, 3, 4, 5]
    """
    
    n = len(listx)
    k = 1
    gap_sequences = [(2 ** k) - 1] #The list is comprised of a finite subset of the infinite sequence defined by (2 ** k) - 1.
    while gap_sequences[-1] < n:
        k = k + 1
        gap_sequences.append((2 ** k) - 1)
    gap_sequences.reverse() # One must use the gap elements generated by the formula in reverse order, since shell sort uses discontiguous lists that DECREMENT.
    for gap_element in gap_sequences:
        sublist_count = n // gap_element # The current number of sublists is equal to how many times one can fit the current gap into the list.
        for start_position in range(sublist_count): # There are as many starting positions as sublists. 
            gap_insertion_sort(listx, start_position, gap_element)
    return listx

def gap_insertion_sort(the_list, start_position, gap): # This algorithm takes the original list and performs insertion sort on discontiguous sublists of the original
                                                       # specified by the start position and gap parameters.
    for i in range(start_position + gap, len(the_list), gap): # Paramater explanation: start_position + gap sets it such that the algorithm, like any insertion sort
    # problem instance, begins by considering the first element to be sorted and thus not in need of consideration. This means we can skip it by proceeding to the
    # next element in the discontinguous list, which is further down the list by the size of the gap sequence. The gap paramater is used as the step by which
    # i increments, in accordance with the discontiguity of the list which is separated by gap number of elements. Finally, the
        current_value = the_list[i]
        current_position = i
        while current_value < the_list[current_position - 1] and current_position > 0:
            the_list[current_position] = the_list[current_position - 1]
            current_position = current_position - 1
        the_list[current_position] = current_value

def quicksort(listx): 
    """
    list of num -> list of num

    return listx sorted from lowest to highest

    >>> x = [15, 76, 56, 3, 14, 21, 19, 0] 
    >>> quicksort(x)
    [0, 3, 14, 15, 19, 21, 56, 76]
    >>> y = [1]
    >>> quicksort(y)
    [1]
    >>> z = [1, 2, 3, 4, 5]
    >>> quicksort(z)
    [1, 2, 3, 4, 5]
    >>> a = [2, 1]
    >>> quicksort(a)
    [1, 2]
    >>> b = [5, 4, 3, 2, 1]
    >>> quicksort(b)
    [1, 2, 3, 4, 5]
    """

    if len(listx) <= 1:
        return listx
    else:
        pivot = len(listx) // 2 
        left_half = []
        right_half = []
        pivot_value = []
        for i in range(len(listx)):
                if listx[i] < listx[pivot]: 
                    left_half.append(listx[i])
                elif listx[i] > listx[pivot]:
                    right_half.append(listx[i])
                else:
                    pivot_value.append(listx[i])
        return quicksort(left_half) + pivot_value + quicksort(right_half)

def RIP_quicksort(listx):
    """
    list of num -> list of num

    Sorts listx in order from smallest to largest.
    RIP stands for Randomized In Place quicksort

    >>> x = [15, 76, 56, 3, 14, 21, 19, 0] 
    >>> RIP_quicksort(x)
    [0, 3, 14, 15, 19, 21, 56, 76]
    >>> y = [1]
    >>> RIP_quicksort(y)
    [1]
    >>> z = [1, 2, 3, 4, 5]
    >>> RIP_quicksort(z)
    [1, 2, 3, 4, 5]
    >>> a = [2, 1]
    >>> RIP_quicksort(a)
    [1, 2]
    >>> b = [5, 4, 3, 2, 1]
    >>> RIP_quicksort(b)
    [1, 2, 3, 4, 5]
    """

    if len(listx) <= 1:
        return listx
    else:
        #Scan the list, partitioning it according to the randomly chosen pivot.
        partition(listx, 0, len(listx) - 1)
    print(listx)

def partition(listx, l, r): #This is the subroutine for RIP_quicksort
    """
    list of num -> list of num

    Partition listx around a randomly chosen pivot within the boundary of listx delineated by l and r.
    """

    #Base case
    if l >= r:
        pass
    else:   
        #Choose a pivot and place it at the beginning of the list.
        pivot_index = random.randint(l, r)
        pivot = listx[pivot_index]
        temp = listx[l]
        listx[l] = pivot
        listx[pivot_index] = temp

        #Partition initialization
        unpartitioned_marker = l + 1 #Elements up to but NOT including this marker are sorted with respect to the pivot.
        pivot_marker = l + 1         #Separates the elements already scanned into those <= to the pivot (those up to the pivot marker),
                                     #and those > the pivot (those beyond pivot_marker)
        found_greater_element = False

        #Partition the list around the pivot
        while unpartitioned_marker <= r:
            if listx[l] > listx[unpartitioned_marker]:
                if found_greater_element == True:
                    leftmost_larger_element = listx[pivot_marker] 
                    newest_less_than_element = listx[unpartitioned_marker]
                    listx[pivot_marker] = newest_less_than_element
                    listx[unpartitioned_marker] = leftmost_larger_element
                pivot_marker += 1
            else:
                found_greater_element = True
            unpartitioned_marker += 1

        listx[l] = listx[pivot_marker - 1]
        listx[pivot_marker - 1] = pivot

        #Recursively sort the remaining halves of the list
        partition(listx, l, pivot_marker - 2)
        partition(listx, pivot_marker, len(listx) - 1)

def merge_sort(listx):
    """
    Return listx sorted from smallest to largest.

    >>> x = [15, 76, 56, 3, 14, 21, 19, 0] 
    >>> merge_sort(x)
    [0, 3, 14, 15, 19, 21, 56, 76]
    >>> y = [1]
    >>> merge_sort(y)
    [1]
    >>> z = [1, 2, 3, 4, 5]
    >>> merge_sort(z)
    [1, 2, 3, 4, 5]
    >>> a = [2, 1]
    >>> merge_sort(a)
    [1, 2]
    >>> b = [5, 4, 3, 2, 1]
    >>> merge_sort(b)
    [1, 2, 3, 4, 5]
    """

    # The base case
    if len(listx) <= 1:
        return listx
    # The recursive calls on the divided portions of the list
    else:
        mid = len(listx) // 2
        left_half = merge_sort(listx[0:mid])
        right_half = merge_sort(listx[mid:])

        # The merge operation variable initializations
        sorted_list = []
        i = 0
        j = 0
        left_length = len(left_half) 
        right_length = len(right_half) 

        # The merging of the two sub-lists
        while i < left_length and j < right_length: 
            if left_half[i] <= right_half[j]:
                sorted_list.append(left_half[i])
                i = i + 1
            else:
                sorted_list.append(right_half[j])
                j = j + 1
        if i == left_length:
            sorted_list.extend(right_half[j:])
        else:
            sorted_list.extend(left_half[i:])
    return sorted_list

#TO DO
def heap_sort(listx):
    """
    Return listx sorted from smallest to largest.
    """

###Search Algorithms###

def iterative_linear_search(listx, item):
    """
    (list of elements, element) -> boolean

    Return True iff item is in listx
    """

    for i in range(len(listx)):
        if listx[i] == item:
            return True
    return False

def recursive_linear_search(listx, item):
    """
    (list of elements, element) -> boolean

    Return True iff item is in listx
    """

    if len(listx) == 0:
        return False 
    else:
        if listx[0] == item:
            return True
        else:
            return recursive_linear_search(listx[1:], item)

def recursive_binary_search(listx, item):
    """
    (list of elements, element) -> boolean

    Precondition: listx must be sorted

    Return True iff item is present within listx
    """

    if len(listx) == 0:
        return False
    else:
        check_index = len(listx) // 2
        if listx[check_index] == item:
            return True
        elif item < listx[check_index]:
            return recursive_binary_search(listx[:check_index], item)
        else:
            return recursive_binary_search(listx[check_index + 1:], item)

def iterative_binary_search(listx, item):
    """
    (list of elements, element -> boolean

    Precondition: listx must be sorted

    Return True iff item is present within listx
    """

    left_marker = 0
    right_marker = len(listx) - 1
    mid_point = len(listx) // 2
    while left_marker <= right_marker:
        if listx[mid_point] == item:
            return True
        elif item < listx[mid_point]:
            right_marker = mid_point - 1 
        else:
            left_marker = mid_point + 1
        mid_point = (left_marker + right_marker) // 2
    return False

###Arithmetic Algorithms###
        
def K_mult(x: 'num', y: 'num') -> 'num':
    """
    Return the product of x and y.
    """

    #Base Case
    if len(str(x)) <= 1:
        return x * y
    else:
        #Convert ints to strings for better digit manipulation
        x_digits = str(x)
        y_digits = str(y)

        #Ensure both digits are of the same length by padding the front with zeroes
        while len(x_digits) < len(y_digits):
            x_digits = '0' + x_digits

        while len(x_digits) > len(y_digits):
            y_digits = '0' + y_digits

        #Ensure that both digits are of even length
        if len(x_digits) % 2 != 0:
            x_digits = '0' + x_digits
            y_digits = '0' + y_digits

        #Divide x and y into smaller numbers a and b, and c and d, respectively.
        a = int(x_digits[0:len(x_digits) // 2])
        b = int(x_digits[len(x_digits) // 2:])
        c = int(y_digits[0:len(y_digits) // 2])
        d = int(y_digits[len(y_digits) // 2:])

        #Recursively compute the products of the expressions used in Karatsuba's Identity
        ac = K_mult(a, c)
        bd = K_mult(b, d)
        ad_plus_bc = K_mult(a + b, c + d) - ac - bd

        #Compute the result of Karatsuba's Identity
        return (ac * (10 ** len(x_digits))) + (ad_plus_bc * (10 ** (len(x_digits) // 2))) + bd


#NOTE: Full implementation is part of the matrix class
def S_matrix_mult(x: 'Matrix', y: 'Matrix') -> 'Matrix': 
    """
    Returns the product of matrix x times matrix y.
    """

    #Store the dimensions of the matrices
    x_matrix_size = x.dim()
    y_matrix_size = y.dim()

    #Pad the matrices to make them square
    if x_matrix_size[0] % 2 != 0:
        new_row = LList()
        for column in range(x_matrix_size[1]):
            new_row.append(0)
        x.matrix_body.append(new_row)
    elif x_matrix_size[1] % 2 != 0:
        for row in range(x_matrix_size[0]):
            x.matrix_body[row].append(0)

    if y_matrix_size[0] % 2 != 0:
        new_row = LList()
        for column in range(y_matrix_size[1]):
            new_row.append(0)
        y.matrix_body.append(new_row)
    elif y_matrix_size[1] % 2 != 0:
        for row in range(y_matrix_size[0]):
            y.matrix_body[row].append(0)

    #Partition the matrices into four submatrices
    x_top_left = Matrix()
    x_top_left.matrix_body = x.matrix_body[0:x_matrix_size[0] // 2]
    print('top left body')
    print(x_top_left.matrix_body)
    for column in range(len(x_top_left.matrix_body)):
        x_top_left.matrix_body[column] = x_top_left.matrix_body[column][0:x_matrix_size[1] // 2]
    print(x_top_left)

    x_bottom_left = Matrix()
    x_bottom_left.matrix_body = x.matrix_body[x_matrix_size[0] // 2:]
    print('bottom left body')
    print(x_bottom_left.matrix_body)
    for column in range(len(x_bottom_left.matrix_body)):
        x_bottom_left.matrix_body[column] = x_bottom_left.matrix_body[column][0:x_matrix_size[1] // 2]
    print(x_bottom_left)

    x_top_right = Matrix()
    x_top_right.matrix_body = x.matrix_body[0:x_matrix_size[0] // 2]
    print(x_top_right.matrix_body)
    for column in range(len(x_top_right.matrix_body)):
        x_top_right.matrix_body[column] = x_top_right.matrix_body[column][x_matrix_size[1] // 2:x_matrix_size[1]] 

    print(x_top_right)

    x_bottom_right = Matrix()
    x_bottom_right.matrix_body = x.matrix_body[x_matrix_size[0] // 2:]
    print(x_bottom_right.matrix_body)
    for column in range(len(x_bottom_right.matrix_body)):
        x_bottom_right.matrix_body[column] = x_bottom_right.matrix_body[column][x_matrix_size[1] // 2:x_matrix_size[1]]

    print(x_bottom_right)

    y_top_left = Matrix()
    y_top_left.matrix_body = y.matrix_body[0:y_matrix_size[0] // 2]
    print('top left body')
    print(y_top_left.matrix_body)
    for column in range(len(y_top_left.matrix_body)):
        y_top_left.matrix_body[column] = y_top_left.matrix_body[column][0:y_matrix_size[1] // 2]
    print(y_top_left)

    y_bottom_left = Matrix()
    y_bottom_left.matrix_body = y.matrix_body[y_matrix_size[0] // 2:]
    print('bottom left body')
    print(y_bottom_left.matrix_body)
    for column in range(len(y_bottom_left.matrix_body)):
        y_bottom_left.matrix_body[column] = y_bottom_left.matrix_body[column][0:y_matrix_size[1] // 2]
    print(y_bottom_left)

    y_top_right = Matrix()
    y_top_right.matrix_body = y.matrix_body[0:y_matrix_size[0] // 2]
    print(y_top_right.matrix_body)
    for column in range(len(y_top_right.matrix_body)):
        y_top_right.matrix_body[column] = y_top_right.matrix_body[column][y_matrix_size[1] // 2:y_matrix_size[1]] 

    print(y_top_right)

    y_bottom_right = Matrix()
    y_bottom_right.matrix_body = y.matrix_body[y_matrix_size[0] // 2:]
    print(y_bottom_right.matrix_body)
    for column in range(len(y_bottom_right.matrix_body)):
        y_bottom_right.matrix_body[column] = y_bottom_right.matrix_body[column][y_matrix_size[1] // 2:y_matrix_size[1]]
    print(y_bottom_right)

    #Recursively compute Strassen's seven products 
    p1 = S_matrix_mult(x_top_left, y_top_right - y_bottom_right)
    p2 = S_matrix_mult(x_top_left + x_top_right, y_bottom_right)
    p3 = S_matrix_mult(x_bottom_left + x_bottom_right, y_top_left)
    p4 = S_matrix_mult(x_bottom_right, y_bottom_left - y_top_left)
    p5 = S_matrix_mult(x_top_left + x_bottom_right, y_top_left + y_bottom_right)
    p6 = S_matrix_mult(x_top_right - x_bottom_right, y_bottom_left + y_bottom_right)
    p7 = S_matrix_mult(x_top_left - x_bottom_left, y_top_left + y_top_right)

    #Compute the matrix quadrants using the above products
    top_left = p5 + p4 - p2 + p6
    bottom_left = p3 + p4
    top_right = p1 + p2
    bottom_right = p1 + p5 - p3 - p2

    #Combine the above quadrants into the final matrix and return it
    top_left.matrix_body.extend(bottom_left.matrix_body)
    top_right.matrix_body.extend(bottom_right.matrix_body)
    for i in range(top_left.dim()[0]):
        top_left.matrix_body[i].extend(top_right.matrix_body[i])
    #print(top_left)
    return top_left

def E_gcd(a: int, b: int) -> int:
    """
    Return the greatest common divisor of a and b

    >>> E_gcd(9, 3)
    3

    >>> E_gcd(16, 24)
    8
    """

    while a != b:
        if a > b:
            a -= b
        else:
            b -= a
    return a
    
###Miscellaneous Algorithms###
def count_inversions(listx):
    """
    list of num -> tuple of (list of num, int)

    Return a tuple containing a sorted version of listx,
    and the number of inversions present in the unsorted version of listx.
    """

    # The base case
    if len(listx) <= 1:
        return (listx, 0)
    # Find all of the inversions only in the left half of the list,
    # and all of the inversions only in the right half of the list
    else:
        mid = len(listx) // 2
        left_half = count_inversions(listx[0:mid])
        right_half = count_inversions(listx[mid:])

        # Initialize variables for the merge operation
        sorted_list = []
        split_inversion_count = 0
        i = 0
        j = 0
        left_length = len(left_half[0]) 
        right_length = len(right_half[0]) 

        # Merge the two sorted sublists
        # and compute the number of split inversions between them
        while i < len(left_half[0]) and j < len(right_half[0]): 
            if left_half[0][i] <= right_half[0][j]:
                sorted_list.append(left_half[0][i])
                i = i + 1
            else:
                sorted_list.append(right_half[0][j])
                j = j + 1
                split_inversion_count = split_inversion_count + len(left_half[0][i:])
        if i == len(left_half[0]):
            sorted_list.extend(right_half[0][j:])
        else:
            sorted_list.extend(left_half[0][i:])

    return (sorted_list, split_inversion_count + left_half[1] + right_half[1])
        

def randomized_selection(listx, k):
    """
    (list of num, int) -> num

    Return the kth smallest element in listx.
    """
   
    if k > len(listx):
        print("INVALID INPUT COMBINATION: the order of the statistic must be less than or equal to the length of the list!")
    else:
        pivot_index = random.randint(0, len(listx) - 1)
        pivot = listx[pivot_index]
        left_half = []
        right_half = []
        pivot_value = []
        for i in range(len(listx)):
            if listx[i] < pivot: 
                left_half.append(listx[i])
            elif listx[i] > pivot:
                right_half.append(listx[i])
            else:
                pivot_value.append(listx[i])
        partitioned_list = left_half + pivot_value + right_half
        new_pivot_index = partitioned_list.index(pivot)
        if new_pivot_index + 1 == k:
            return pivot
        elif new_pivot_index + 1 > k:
            return randomized_selection(partitioned_list[:new_pivot_index], k)
        else:
            return randomized_selection(partitioned_list[new_pivot_index + 1:], k - (new_pivot_index + 1))

<<<<<<< HEAD
=======
##def maximum_subsequence_sum(sequence):
##    """
##    Return the maximum contiguous subsequence sum within sequence, and the indices delineating said subsequence.
##    """
##
##    if len(sequence) == 0:
##        return (0, "N/A", "N/A") #Because of the nature of integer division used to compute the midpoint index,
##                 #this base case will never actually be reached on inputs >= 1. It is only here
##                 #for the sake of completeness
##    elif len(sequence) == 1:
##        return (sequence[0], 0, 0)
##    #Recursively compute the maximum subsequence for each half of the original sequence
##    else:
##        midpoint_index = len(sequence) // 2
##        left_maximum = maximum_subsequence_sum(sequence[:midpoint_index])
##        right_maximum = maximum_subsequence_sum(sequence[midpoint_index:])
##        split_maximum = (sum(sequence[left_maximum[1]:right_maximum[2] + 1]), left_maximum[1], right_maximum[2] + 1)
##
##    #Compare the subsequence sums, returning the tuple which contains the largest sum
##        if split_maximum[0] > left_maximum[0] and split_maximum[0] > right_maximum[0]:
##            return (split_maximum, left_maximum[1], right_maximum[2])
##        elif left_maximum[0] >= right_maximum[0]:
##            return left_maximum
##        else:
##            return right_maximum

>>>>>>> 065814e8b6dfd54a9fe3d6ee12331e28e75be793
###Graph Algorithms###

#Need to find a way to infer what minimum cut is represented by each super node, and compare that against the best cut found so far
#NOT DEBUGGED
def K_contraction(graphx):
    """
    Attempts to find the minimum cut of graphx

    Precondition: graphx must have at least 2 nodes
    """

    required_iterations = (len(graphx.graph_elements) ** 2) * math.log2(graphx.graph_elements)
    for i in range(required_iterations):
        while len(graphx.graph_elements) > 2:
            #Randomly selet a contracting node and remove it from the graph element list
            contracting_node_value = graph_elements[random.randint(0, len(graph_elements) - 1)]
            graphx.graph_elements.remove(contracting_node_value)
            #Find the node to contract
            contracting_node = BFS_search(self, contracting_node_value)
            #Randomly select from the contracting node's adjacent nodes another node to absorb the contracting node's edges
            accepting_node = contracting_node.adjacent_nodes[random.randint(0, len(contracting_node.adjacent_nodes) - 1)]
            #Remove the self loop that would otherwise generate from the contraction
            contracting_node.adjacent_nodes.remove(accepting_node)
            #Merge the non-self looping edges of the contracting node into the accepting node
            accepting_node.adjacent_nodes.extend(contracting_node.adjacent_nodes)
    
<<<<<<< HEAD
=======
#Semi tested
>>>>>>> 065814e8b6dfd54a9fe3d6ee12331e28e75be793
def BFS(graphx: 'Graph', node_value: object, start_node_index=0) -> 'GNode':
    """
    Return the node which contains value node_value, otherwise raise an error"
    """

    layer_queue = Queue()
    layer_queue.enqueue(graphx.graph_elements[start_node_index])
    layer_queue.first().mark_explored()
    while layer_queue.is_empty() == False:
        current_node = layer_queue.first()
<<<<<<< HEAD
=======
        #print(current_node)
        #print("layer queue first: " + str(layer_queue.first()))
        #print("current node: " + str(current_node))
>>>>>>> 065814e8b6dfd54a9fe3d6ee12331e28e75be793
        if current_node.value == node_value:
            for node in graphx.graph_elements:
                node.reset_node()
            return current_node
        else:
<<<<<<< HEAD
            layer_queue.dequeue()
=======
           # print("Node to dequeue: " + str(layer_queue.first()))
            #print("before dequeque: " + str(layer_queue))
            layer_queue.dequeue()
            #print("After dequeue: " + str(layer_queue))
>>>>>>> 065814e8b6dfd54a9fe3d6ee12331e28e75be793
            for node in current_node.adjacent_nodes:
                if node.explored == False:
                    node.mark_explored()
                    layer_queue.enqueue(node)
    raise NodeAbsentError()

<<<<<<< HEAD
#This implementation has a subtle bug; it is a good question to ask to test debugging skills
##def Shortest_Num_Steps(graphx: 'Graph', x: object, y: object) -> int:
##    "Return the shortest path distance in terms of steps from node x to node y in graphx"
##
##    source_node = graphx.get_node_by_value(x)
##    path_distance = 0
##    layer_queue = Queue()
##    layer_queue.enqueue(source_node)
##    layer_queue.first().mark_explored()
##    while layer_queue.is_empty() == False:
##        current_node = layer_queue.first()
##        if current_node.value == y:
##            for node in graphx.graph_elements:
##                node.reset_node()
##            return path_distance
##        else:
##            layer_queue.dequeue()
##            for node in current_node.adjacent_nodes:
##                if node.explored == False:
##                    node.mark_explored()
##                    layer_queue.enqueue(node)
##        path_distance += 1
##    raise AbsentNodeError()

def Shortest_Num_Steps(graphx: 'Graph', x: object, y: object) -> int:
    "Return the shortest path distance in terms of steps from node x to node y in graphx"

    source_node = graphx.get_node_by_value(x)
    layer_queue = Queue()
    layer_queue.enqueue(source_node)
    layer_queue.first().mark_explored()
    while layer_queue.is_empty() == False:
        current_node = layer_queue.first()
        if current_node.value == y:
            distance_to_return = current_node.distance
            for node in graphx.graph_elements:
                node.reset_node()
            return distance_to_return
        else:
            layer_queue.dequeue()
            for node in current_node.adjacent_nodes:
                if node.explored == False:
                    node.mark_explored()
                    node.distance = current_node.distance + 1
                    layer_queue.enqueue(node)
    raise AbsentNodeError()

def undirected_CC(graph_x: 'Graph'):
=======
#NOT DEBUGGED: Need to make the nodes keep track of ther distance
def Shortest_Num_Steps(graphx: 'Graph', x: object, y: object) -> int:
    "Return the shortest path distance in terms of steps from node x to node y in graphx"

    source_node = BFS(graphx, x)
    layer_queue = Queue()
    layer_queue.enqueue(source_node)
    layer_queue.first().mark_explored()
    path_distance = 0
    while layer_queue.is_empty() == False:
        current_node = layer_queue.first()
        print(current_node)
        if current_node.value == y:
            for node in graphx.graph_elements:
                node.reset_node()
            return path_distance
        else:
            layer_queue.dequeue()
            path_distance += 1
            for node in current_node.adjacent_nodes:
                if node.explored == False:
                    node.mark_explored()
                    layer_queue.enqueue(node)
    raise AbsentNodeError()

def undirected_connectivity(self: 'Graph'):
>>>>>>> 065814e8b6dfd54a9fe3d6ee12331e28e75be793
    "Return the connected components of the given graph."

    connected_components = LList()
    current_node_index = 0
<<<<<<< HEAD
    for node in graph_x.graph_elements:
        if node.explored == False:
            component_elements = LList()
            layer_queue = Queue()
            layer_queue.enqueue(graph_x.graph_elements[current_node_index])
            layer_queue.first().mark_explored()
            while layer_queue.is_empty() == False:
=======
    for node in self.graph_elements:
        if node.explored == False:
            component_elements = LList()
            layer_queue = Queue()
            layer_queue.enqueue(graphx.elements[current_node_index])
            layer_queue.first().mark_explored()
            while layer_queue.is_empty == False:
>>>>>>> 065814e8b6dfd54a9fe3d6ee12331e28e75be793
                current_node = layer_queue.first()
                component_elements.append(current_node)
                layer_queue.dequeue()
                for adj_node in current_node.adjacent_nodes:
                    if adj_node.explored == False:
                        adj_node.mark_explored()
                        layer_queue.enqueue(adj_node)
<<<<<<< HEAD
            new_component = Graph()
            new_component.graph_elements = component_elements
            connected_components.append(new_component) 
        current_node_index += 1
    for node in graph_x.graph_elements:
        node.reset_node()
    return connected_components
                            
=======
                current_node_index += 1
            new_component = Graph()
            new_component.graph_elements = component_elements
            new_component.start = current_node_index
            connected_components.append(new_component)   
    return connected_components

#TODO: Redo This

def Tarjan_SCC(graphx: 'Graph') -> 'List of Graphs':
    "Return a list consisting of the strongly connected components of graphx"

    node_index = 0
    node_tracker = Stack()

    for node in graphx.graph_elements:
        if (node.explored == False):
            strong_connect(node)

    def strong_connect(node: 'GNode') -> 'Graph':
        "Return the strongly connected component reachable from node."

        DFS_stack = Stack()
        node.mark_explored()
        node.low_link = index
        DFS_stack.push(node)
        node_tracker.push((node, node_index))
        node_index += 1
        while DFS_stack.is_empty() != True:
            current_node = DFS_stack.peek()
            DFS_stack.pop()
            for adj_node in current_node.adjacent_nodes:
                if adj_node.explored == False:
                    adj_node.explored = True
                    DFS_stack.push(adj_node)
                    node_tracker((adj_node, node_index))
                    node_index += 1
                            
#Semi-tested
>>>>>>> 065814e8b6dfd54a9fe3d6ee12331e28e75be793
def Iterative_DFS(graphx: 'Graph', node_value: object, start_node_index=0) -> 'GNode':
    "Return the node which contains node_value, otherwise return an AbsentNodeError"

    search_stack = Stack()
    search_stack.push(graphx.graph_elements[start_node_index])
    search_stack.peek().mark_explored()
    while search_stack.is_empty() == False:
        current_node = search_stack.peek()
<<<<<<< HEAD
=======
        print(current_node.value)
>>>>>>> 065814e8b6dfd54a9fe3d6ee12331e28e75be793
        if current_node.value == node_value:
            for node in graphx.graph_elements:
                node.reset_node()
            return current_node
        else:
<<<<<<< HEAD
            search_stack.pop()
=======
            #print("stack before pop: " + str(search_stack))
            search_stack.pop()
            #print("search stack after pop: " + str(search_stack))
>>>>>>> 065814e8b6dfd54a9fe3d6ee12331e28e75be793
            for node in current_node.adjacent_nodes:
                if node.explored == False:
                    node.mark_explored()
                    search_stack.push(node)
    raise NodeAbsentError()
    
#NOT DEBUGGED
def Topoological_Sort(graphx: 'Graph') -> 'LList':
    """
    Return a list of graph nodes in topological order

    Pre-condition: graphx must be acyclic
<<<<<<< HEAD
    """ 
=======
    """

    
>>>>>>> 065814e8b6dfd54a9fe3d6ee12331e28e75be793
    nodes_and_labels = LList()
    current_node_label = graphx.num_nodes()
    for element in graphx.graph_elements:
        if element.explored == False:
            Recursive_DFS(graphx, element)

    def Recursive_DFS(graphx: 'Graph', start_node=None) -> 'GNode':
        "Return the node which contains node_value, otherwise raises a NodeAbsentError"

        current_node = start_node
        current_node.mark_explored()
        for node in current_node.adjacent_nodes:
            if node.explored == False:
                Recursive_DFS(graphx, node)
        nodes_and_labesl.append((current_node, current_node_label))
        current_node_label -= 1
    return nodes_and_labels

###DATA STRUCTURES###
class Node:

    def __init__(self: 'Node', value=None) -> None:
        "Initialize a generic Node with value value"

        self.value = value

    def __repr__(self: 'Node') -> str:
        "Return a string representation of this Node and its value"

        return "Node(" + str(self.value) + ")"


###Linked List###
class LNode(Node):
    """A Node object used in linked lists"""

    def __init__(self: 'Node', value: object, nxt=None):
        """Initialize an instance of _Node class, storing the value of item and
        referencing link.
        Pre-condition: link must be either an instance of LNode or None.
        """
        
        super().__init__(value)
        self.nxt = nxt

    def __repr__(self: 'Node') -> str:
        return 'Node(' + str(self.value) + ')->' + str(self.nxt)

class LList:
    """A list implementation composed of singly linked Nodes."""

    def __init__(self: 'LList'):
        """Initialize an empty instance of LinkedList."""

        self.list_head = None
        self.list_tail = None
        self.num_items = 0

    #Perhaps alter the representation such that matrices constructed out of them have a good str rep
    def __repr__(self: 'LList') -> str:
        """Return a string representation of the given linked list."""

        if self.list_head == None:
            return '[]'
        else:
            str_rep = '[' + str(self.list_head.value) + ', '
        current_node = self.list_head.nxt
        while current_node != None and id(current_node) != id(self.list_head):
            str_rep = str_rep + str(current_node.value) + ', '
            current_node = current_node.nxt
        return str_rep[:len(str_rep) - 2] + ']'

    def __len__(self: 'LList') -> int:
        """Return the number of elements in the list."""

        return self.num_items

    def __add__(self: 'LList', other: 'LList') -> 'LList':
        "Return a new list, which is a concatenation of the current list and other"

        new_list = LList()
        new_list.list_head = self.list_head
        new_list.list_tail = other.list_tail
        for i in range(len(self)):
            new_list.append(self[i])
        for i in range(len(other)):
            new_list.append(other[i])
        return new_list

    def __contains__(self: 'LList', item: object) -> bool:
        """ Return True iff element is in the list."""

        if self.num_items == 0:
            return False
        current_node = self.list_head
        current_value = current_node.value
        current_value_index = 0
        while current_node.nxt != None:
            if current_value == item:
                return True
            else:
                current_node = current_node.nxt
                current_value = current_node.value
                current_value_index += 1
        return current_value == item

    def __getitem__(self: 'LList', index: int) -> object:
        """Return the element at index index or the slice delineated thereof."""

        current_node = self.list_head
        current_node_index = 0
        list_slice = LList()

        if isinstance(index, slice):
            if index.stop == None:
                target_index = self.num_items
            elif index.stop < 0 or index.stop > self.num_items:
                raise IndexError("Invalid Index: " + str(index))
            else:
                target_index = index.stop
            if index.start == None:
                starting_index = 0
            elif index.start < 0 or index.start >= self.num_items:
                raise IndexError("Invalid Index: " + str(index))
            else:
                starting_index = index.start
            while current_node_index != starting_index:
                current_node = current_node.nxt
                current_node_index += 1
            while current_node_index != target_index:
                list_slice.append(current_node.value)
                current_node = current_node.nxt
                current_node_index += 1
            return list_slice
        else:
            if index < 0 or index >= self.num_items:
                raise IndexError("Invalid Index: " + str(index))
            else:
                target_index = index
            current_node_index = 0
            while current_node_index != target_index:
                current_node = current_node.nxt
                current_node_index += 1
            return current_node.value

    def __setitem__(self: 'LList', index: int, item: object) -> None:
        "Insert item at index index."

        if index < 0 or index >= self.num_items:
            print("set item index:" + str(index))
            raise IndexError()
        else:
            current_node = self.list_head
            current_index = 0
            while current_index != index:
                current_node = current_node.nxt
                current_index += 1
            current_node.value = item

    def insert(self: 'LList', index: int, item: object) -> None:
        "Insert item before index index in the list."

        if index <= -1:
            raise IndexError()
        else:
            if index == 0:
                new_node = LNode(item, self.list_head)
                self.list_head = new_node
            elif index >= self.num_items:
                new_node = LNode(item)
                self.list_tail.nxt = new_node
                self.list_tail = new_node
            else:
                current_node = self.list_head
                current_index = 0
                while current_index != index - 1:
                    current_node = current_node.nxt
                    current_index += 1
                new_node = LNode(item, current_node.nxt)
                current_node.nxt = new_node
        self.num_items += 1
                
    def append(self: 'LList', item: object) -> None:
        """Attach item to the end of the list"""

        new_node = LNode(item, None)
        if self.num_items == 0:
            self.list_head = new_node
            self.list_tail = new_node
        elif self.num_items == 1:
            self.list_tail = new_node
            self.list_head.nxt = self.list_tail
        else:
            self.list_tail.nxt = new_node
            self.list_tail = self.list_tail.nxt
        self.num_items += 1

    def pop(self: 'LList', index=0) -> object:
        """Remove and return item at index index"""

        if index >= self.num_items or index < 0:
            raise IndexError()
        else:
            if index == 0:
                to_return = self.list_head.value
                self.list_head = self.list_head.nxt
            else:
                current_node = self.list_head
                current_node_index = 0
                while current_node_index != index - 1:
                    current_node = current_node.nxt
                    current_node_index += 1
                to_return = current_node.nxt.value
                current_node.nxt = current_node.nxt.nxt
                if index == self.num_items - 1:
                    self.list_tail = current_node
        self.num_items -= 1
        return to_return
        
    def remove(self: 'LList', item: object) -> None:
        """Remove the first occurence of item. Raises a ValueError if item not present."""

        if self.list_head == None:
            raise ValueError("The item: " + str(item) + " is not present within the list")

        #Handle edge case where item is the head of the list
        elif self.list_head.value == item:
            self.list_head = self.list_head.nxt
            self.num_items -= 1
        else:
            current_node = self.list_head
            while current_node.nxt != None and current_node.nxt.value != item:
                current_node = current_node.nxt
            if current_node.nxt != None:
                #Check if the value to be removed is the last one, and, if so, update the list tail accordingly.
                if current_node.nxt.nxt == None:
                    self.list_tail = current_node
                current_node.nxt = current_node.nxt.nxt
                self.num_items -= 1
            else:
                raise ValueError("The item: " + str(item) + " is not present within the list")
        
    def extend(self: 'LList', iterable: 'iterable') -> None:
        """Extend the list by appending elements from the iterable"""

        for i in range(len(iterable)):
            self.append(iterable[i])
        
    def sort(self: 'LList') -> None: 
        """sort the list from smallest to largest"""

        RIP_quicksort(self)

    def count(self: 'LList', item: object) -> int:
        """return the number of occurences of value"""

        current_node = self.list_head
        item_count = 0
        while current_node != None:
            if current_node.value == item:
                item_count += 1
            current_node = current_node.nxt
        return item_count

    def clear(self: 'LList') -> None:
        """remove all elements from the list"""

        self.list_head = LNode(None, None)
        self.list_tail = self.list_head
        self.num_items = 0

    #TODO: Implement this
<<<<<<< HEAD
##    def reverse(self: 'LList') -> None:
##        """reverse the ordering of the elements in the list"""
##	pass
=======
    def reverse(self: 'LList') -> None:
        """reverse the ordering of the elements in the list"""

        pass
>>>>>>> 065814e8b6dfd54a9fe3d6ee12331e28e75be793

###Stack###

class EmptyStackError(Exception):
    "An exception raised when the stack is empty and any access operations are performed upon it"
<<<<<<< HEAD
    pass

class Stack:
    """An implementation of the Stack ADT"""
=======

    pass

class Stack:
    """A Stack data strucutre."""
>>>>>>> 065814e8b6dfd54a9fe3d6ee12331e28e75be793

    def __init__(self: 'Stack') -> None:
        """Initialize an insance of the Stack ADT."""

        self.stack_body = LList()

    def __repr__(self: 'Stack') -> str:
        """Return a string representation of the current stack"""

        str_rep = ''
        i = len(self.stack_body) - 1
        while i >= 0:
            str_rep = str_rep + str(self.stack_body[i]) + '\n'
            i -= 1
        return str_rep

    def __len__(self: 'Stack') -> int:
        "Return the number of elements in this stack"

        return len(self.stack_body)

    def push(self: 'Stack', item: object) -> None:
        """Push an item onto the top of the stack."""

        self.stack_body.append(item)

    def pop(self: 'Stack') -> object:
        """Remove and return the top element on the stack"""

        if self.__len__() >= 1:
            return self.stack_body.pop(len(self.stack_body) - 1)
        else:
            raise EmptyStackError()

    def peek(self: 'Stack') -> object:
        "Return the value at the top of the stack"

        if self.__len__() >= 1:
            return self.stack_body[len(self.stack_body) - 1]
        else:
            raise EmptyStackError()

    def is_empty(self: 'Stack') -> bool:
        """return True iff the stack is empty"""

        return len(self.stack_body) == 0

###Queue###
"""An implementation of the Queue ADT."""

class EmptyQueueError(Exception):

    """An exception raised when attempting to dequeue from an empty queue.
    """

    pass


class Queue: #Perhaps redo this using my own LinkedList as a body

    """A collection of items stored in 'first-in, first-out' (FIFO) order.
    Items can have any type.

    Supports standard operations: enqueue, dequeue, front, is_empty.
    """

    def __init__(self: 'Queue') -> None:
        """
        Initialize this queue.

        >>> q = Queue()
        >>> isinstance(q, Queue)
        True
        """

        self.queue_body = LList()

    def __repr__(self: 'Queue') -> str:
        """
        Return a string representation of the queue.
        """
        
        return 'Queue: ' + str(self.queue_body)

    def __len__(self: 'Queue') -> int:
        """Return the number of elements within the Queue"""

        return len(self.queue_body)

    def enqueue(self: 'Queue', item: object) -> None:
        """
        Add item to the back of this queue.

        item - object to put in queue

        >>> q = Queue()
        >>> q.enqueue(5)
        >>> q.first()
        5
        """

        self.queue_body.insert(0, item)
                
    def dequeue(self: 'Queue') -> object:
        """
        Remove and return the front item in this queue.

        >>> q = Queue()
        >>> q.enqueue(5)
        >>> q.enqueue(6)
        >>> q.dequeue()
        >>> q.first()
        6
        """

        if self.is_empty():
            raise EmptyQueueError()
        else:
            self.queue_body.pop(len(self.queue_body) - 1)
        

    def first(self: 'Queue') -> object:
        """
        Return the front item in this queue without removing it.

        >>> q = Queue()
        >>> q.enqueue(5)
        >>> q.enqueue(6)
        >>> q.first()
        5
        """

        if self.is_empty():
            raise EmptyQueueError()
        else:
            return self.queue_body[len(self.queue_body) - 1]
            
        

    def is_empty(self: 'Queue'):
        """
        Return True iff this queue is empty.

        >>> Queue().is_empty()
        True
        """

        return len(self.queue_body) == 0

###Dequeue###
class EmptyDequeError(Exception):
    "An exception raised when one tries to access an empty deque"

    pass

class Deque:
    "A container class in which elements can be added or removed from both the front and back ends"

    def __init_(self: 'Deque') -> None:
        "Initialize a new empty deque object"

        self.body = LList()

    def __repr__(self: 'Deque') -> str:
        "Return a string representation of this deck object"

        return "Deque: " + str(self.body)

    def __len__(self: 'Deque') -> int:
        "Return the number of elements within this deque"

        return len(self.body)

    def enqueue_front(self: 'Deque', item: object) -> None:
        "Add a new item to the front of this deque object"

        self.body.append(item)

    def enqueue_back(self: 'Deque', item: object) -> None:
        "Add a new item to the back of this deque object"

        self.body.insert(0, item)

    def dequeue_front(self: 'Deque', item: object) -> object:
        "Remove and return the item at the front of this deque"

        if self.__len__() >= 1:
            return self.body.pop(len(self.body) - 1)
        else:
            raise EmptyDequeError()

    def dequeue_back(self: 'Deque', item: object) -> object:
        "Remove and return the item at the back end of this queue"

        if self.__len__() >= 1:
            return self.body.pop(0)
        else:
            raise EmptyDequeError()

    def examine_front(self: 'Deque') -> object:
        "Return the element at the front of this deque"

        if self.__len__() >= 1:
            return self.body[len(self.body) - 1]
        else:
            raise EmptyDequeError()

    def examine_back(self: 'Deque') -> object:
        "Return the element at the back of this deque"

        if self.__len__() >= 1:
            return self.body[0]
        else:
            raise EmptyDequeError()

    def is_empty(self: 'Deque') -> bool:
        "Return True iff this deque is empty"

        return self.__len__() == 0

###Graph###
#DESIGN ISSUES#
"""
-Should nodes be assumed to have unique values?
    -If so, we must protect against a user assigning values to nodes that already contain that value
    -If not, we need a way to identify nodes apart from thier values. Use the identity of memory addressed perhaps?
    -Should the user have to pass in nodes as parameters, or values, and ten odes are built automatically?
    -Go through the doc strings and change data types of parameters from GNode to object if I don;t require actual nodes as inputs
-Perhaps the nodes should be identifies via the indexes of the graph elements list. This would provide a way to reference nodes without needing to know thier values
-Should the graph element list contain nodes, or the values of the nodes? If the former, much of the graph operations could be altered to operate on this list.
"""

class NodeAbsentError(Exception):
    "An exception raised when the specified node is not found within the graph"

    pass

class GNode(Node):
    def __init__(self: 'GNode', value) -> None:
        "Initialize a graph node object with value value."
<<<<<<< HEAD
        super().__init__(value)
        self.adjacent_nodes = LList()
        self.explored = False
        self.distance = 0

    def __repr__(self: 'GNode') -> str:
        "Return a string representation of this GNode"
        return "GNode(" + str(self.value) + ")"

    def __eq__(self: 'GNode', other: 'GNode') -> bool:
        "Return true iff the current node and other have the same value"
=======

        super().__init__(value)
        self.adjacent_nodes = LList()
        self.explored = False
        #For strongly connected components algorithms
        self.low_link = None

    #TODO: Make this more informative
    def __repr__(self: 'GNode') -> str:
        "Return a string representation of this GNode"

        return "GNode(" + str(self.value) + ")"

    #Review whether nodes or not should be unique in their values
    def __eq__(self: 'GNode', other: 'GNode') -> bool:
        "Return true iff the current node and other have the same value"

>>>>>>> 065814e8b6dfd54a9fe3d6ee12331e28e75be793
        return self.value == other.value

    def mark_explored(self: 'GNode') -> None:
        "Mark this node as having been explored"
<<<<<<< HEAD
=======

>>>>>>> 065814e8b6dfd54a9fe3d6ee12331e28e75be793
        self.explored = True

    def reset_node(self: 'GNode') -> None:
        "Mark this node as unexplored"
<<<<<<< HEAD
        self.explored = False
        self.distance = 0

#Review and debug this implementation, making sure the final version is used correctly by the graph algorithms
class Graph:
    "A directed/undirected graph object"

    def __init__(self: 'Graph', directed=False) -> None:
        "Initialize an empty graph"
        self.graph_elements = LList()
        self.directed = directed

    #TODO: Improve This
##    def __repr__(self: 'Graph') -> str:
##        "Return a string representation of this graph object"
##        "Graph:\n" + str(self.start)

    def __contains__(self: 'Graph', value) -> bool:
        "Return True iff item is a node (value) in the graph, else return false"
        for node in self.graph_elements:
            if node.value == value:
=======

        self.explored = False

#Review and debug this implementation, making sure the final version is used correctly by the graph algorithms
class Graph:
    "An directed/undirected graph object"

    def __init__(self: 'Graph', item=None, directed=False) -> None:
        "Initialize an empty graph, or a graph with a single starting node."

        self.graph_elements = LList()
        if item != None:
            self.start = GNode(item)
            self.graph_elements.append(self.start)
        else:
            self.start = None
        self.directed = directed

    #TODO: Make this more informative
    def __repr__(self: 'Graph') -> str:
        "Return a string representation of this graph object"

        "Graph:\n" + str(self.start)

    def __contains__(self: 'Graph', item: object) -> bool:
        "Return True iff item is a node (value) in the graph"

        for node in self.graph_elements:
            if node.value == item:
>>>>>>> 065814e8b6dfd54a9fe3d6ee12331e28e75be793
                return True
        return False

    def __len__(self: 'Graph') -> int:
        "Return the number of nodes in this graph"
<<<<<<< HEAD
        return len(self.graph_elements)

    #TODO: Determine what should happen if a node does not exist (Exception? Return False?)	
    def get_node_by_value(self: 'Graph', value):
        "Return the node with value value, if present, else raises a NodeAbsentError"
        for node in self.graph_elements:
            if node.value == value:
                return node
        raise NodeAbsentError

    def adjacent(self: 'Graph', x, y) -> bool:
        "Return True iff there is an edge between nodes x and y"
        x_adjacents = self.get_node_by_value(x).adjacent_nodes
=======

        return len(self.graph_elements)

    def adjacent(self: 'Graph', x: 'GNode', y: 'GNode') -> bool:
        "Return True iff  there is an edge between nodes x and y"

        x_adjacents = BFS(self, x).adjacent_nodes
>>>>>>> 065814e8b6dfd54a9fe3d6ee12331e28e75be793
        for node in x_adjacents:
            if node.value == y:
                return True
        return False

    def neighbours(self: 'Graph', x: 'GNode') -> 'LList':
        "Return a list of all nodes y, such that there is an edge from x to y"
<<<<<<< HEAD
        node_x = self.get_node_by_value(x)
        return node_x.adjacent_nodes

    def add_node(self: 'Graph', x, y=None) -> bool:
        """
        Attach a new node to the current graph, such that there is an edge connecting node x to node y.
	x will only point to y if the grapg is directed. y is an optional parameter; if it is not provided, a new disconnected node will be added to the graph.
	If a value for y is supplied, but the node does not exist, the method will return false.
        """
        new_node = GNode(x)
        if y != None:
            old_node = self.get_node_by_value(y)
            new_node.adjacent_nodes.append(old_node)
            if self.directed == False:
                old_node.adjacent_nodes.append(new_node)
        self.graph_elements.append(new_node)

    #TODO: What about the case where we want to delete the node but maintain its corresponding edges
    def delete_node(self: 'Graph', x) -> bool:
        """
        Delete the node and its corresponding edges, if present.
        """
        node_to_delete = self.get_node_by_value(x)
=======

        x_adjacents = BFS(self, x).adjacent_nodes
        neighbour_list = LList()
        for node in x_adjacents:
            neighbour_list.append(node.value)
        return neighbour_list

    def add_node(self: 'Graph', x: object, y: object) -> None:
        """"
        Attach a node corresponding to object y to the node corresponsing to
        object x, with an edge, connecting it to the graph
        """

        new_node = GNode(y)
        old_node = BFS(self, x)
        old_node.adjacent_nodes.append(new_node)
        if self.directed == False:
            new_node.adjacent_nodes.append(old_node)
        self.graph_elements.append(new_node)

    def delete_node(self: 'Graph', item: object) -> None:
        """
        Delete the graph node and the concomitant edges corresponding to obejct item, if present.
        Otherwise, return an AbsentNodeError
        """

        node_to_delete = BFS(self, item)
>>>>>>> 065814e8b6dfd54a9fe3d6ee12331e28e75be793
        for node in node_to_delete.adjacent_nodes:
            node.adjacent_nodes.remove(node_to_delete)
        node_to_delete.adjacent_nodes = LList()
        self.graph_elements.remove(node_to_delete)

<<<<<<< HEAD
    def add_edge(self: 'Graph', x, y) -> None:
        """
        Add an edge connecting the nodes which correspond to objects x and y, if present.
        Returns true on success and false on failure. If the graph is directed, x will point to y only.
        """
        node_x = self.get_node_by_value(x)
        node_y = self.get_node_by_value(y)
=======
    def add_edge(self: 'Graph', x: object, y: object) -> None:
        """
        Add an edge connecting the nodes which correspond to objects x and y, if present.
        Otherwise, raise an AbsentNodeError. If the graph is directed, x will point to y.
        """

        node_x = BFS(self, x)
        node_y = BFS(self, y)
>>>>>>> 065814e8b6dfd54a9fe3d6ee12331e28e75be793
        node_x.adjacent_nodes.append(node_y)
        if self.directed == False:
            node_y.adjacent_nodes.append(node_x)
               
    def delete_edge(self: 'Graph', x: object, y: object) -> None:
        """
<<<<<<< HEAD
        Remove the edge attaching nodes, if present,  which correspond to objects x and y, 
	possibly breaking the graph into multiple connected components. Returns true on success false on failure.
        """
        node_x = self.get_node_by_value(x)
        node_y = self.get_node_by_value(y)
        node_x.adjacent_nodes.remove(node_y)
        node_y.adjacent_nodes.remove(node_x)

    def set_value(self: 'Graph', node , value) -> None:
        "Set the value of node to value value"
        node_to_set = self.get_node_by_value
        node_to_set.value = value

    def is_empty(self: 'Graph') -> bool:
        """Return True iff there are no nodes in the given graph"""
=======
        Remove the edge attaching nodes, if present,  which correspond to objects x and y,
        breaking the graph into multiple connected components. Otherwise, raise an AbsentNodeError
        """
    
        node_x = BFS(self, x)
        node_y = BFS(self, y)
        node_x.adjacent_nodes.remove(node_y)
        node_y.adjacent_nodes.remove(node_x)

    def set_value(self: 'Graph', node: object , item: object) -> None:
        "Set the value of node to value item."

        BFS(self, node).value = item

    def get_value(self: 'Graph', i: 'int') -> object:
        "Return the value of the node indexed at i"

        return self.graph_elements[i].value

    def is_empty(self: 'Graph') -> bool:
        """Return True iff there are no nodes in the given graph"""

>>>>>>> 065814e8b6dfd54a9fe3d6ee12331e28e75be793
        return self.__len__() == 0

#Vector#
class Vector:
    "A implementation of the mathematical structure of a vector"

    #Perhaps make it possible for my own list to accept a list of initialization variables, then I can use my LList to implement the vector body
    def __init__(self: 'Vector', elements=[]) -> None:
        """
        Initialize a vector object comprised of the numbers in elements

        Pre-condition: the individual elements in the elements parameter must be numbers
        """

        self.vector_elements = LList()
        for element in elements:
            self.vector_elements.append(element)

    def __repr__(self: 'Vector') -> str:
        "Return a string representation of the current vector object"

        return "Vec:" + str(self.vector_elements)

    def __len__(self: 'Vector') -> int:
        "Return the number of elements within the current vector"

        return len(self.vector_elements)

    def __eq__(self: 'Vector', other: object) -> bool:
        "Return True iff the current vector and other have the same elements in the same order"

        if not isinstance(other, Vector):
            return False
        elif len(self.vector_elements) != len(other.vector_elements):
            return False
        else:
            for i in range(len(self.vector_elements)):
                if self.vector_elements[i] != other.vector_elements[i]:
                    return False
        return True

    def __add__(self: 'Vector', other: 'Vector') -> 'Vector':
        """
        Return the sum of the current vector and other

        Pre-condition: both vectors must be of the same length
        """

        if len(self.vector_elements) != len(other.vector_elements):
            raise IndexError("The input vectors are not of equal length!")
        else:
            vector_sum = LList()
            for i in range(len(self.vector_elements)):
                if isinstance(self.vector_elements[i], (int, float)):
                    vector_sum.append(self.vector_elements[i] + other.vector_elements[i])
                else:
                    raise TypeError("One of the elements in the input vectors is not a number!")
            return vector_sum

    def __sub__(self: 'Vector', other: 'Vector') -> 'Vector':
        "Return the difference of the current vector and other"

        if len(self.vector_elements) != len(other.vector_elements):
            raise IndexError("The input vectors are not of equal length!")
        else:
            vector_difference = LList()
            for i in range(len(self.vector_elements)):
                if isinstance(self.vector_elements[i], (int, float)):
                    vector_difference.append(self.vector_elements[i] - other.vector_elements[i])
                else:
                    raise TypeError("One of the elements in the input vectors is not a number!")
            return vector_difference

    def __mul__(self: 'Vector', other: 'Vector or Scalar') -> 'Vector':
        "Reurn the product of multipling the current vector by other"

        if isinstance(other, int) or isinstance(other, float):
            vector_product = [other * element for element in self]
            return vector_product
        elif len(self.vector_elements) != len(other.vector_elements):
            raise IndexError("The input vectors are not of equal length!")
        else:
            vector_product = LList()
            for i in range(len(self.vector_elements)):
                if isinstance(self.vector_elements[i], (int, float)):
                    vector_product.append(self.vector_elements[i] * other.vector_elements[i])
                else:
                    raise TypeError("One of the elements in the input vectors is not a number!")
            return sum(vector_product)

    def __getitem__(self:' Vector', index: int) -> object:
        "Retrieve the element within index index of the current vector"

        return self.vector_elements[index]

    def __setitem__(self: 'Vector', index: int, element: 'num') -> None:
        "Add param element to vector at position index"

        self.vector_elements[index] = element

    def __contains__(self: 'Vector', item: 'num') -> bool:
        "Return True iff item is present within the current vector"

        return item in self.vector_elements

    def pop(self: 'Vector', index=0) -> 'num':
        "Remove and return the element at index index"

        return self.vector_elements.pop(index)

    def append(self: 'Vector', element: 'num') -> None:
        "Append the parameter element to the end of the vector"

        self.vector_elements.append(element)

    
#Matrix#
#TODO: modify the methods of the class such that they react appropriately (raise an error) when None data type is found
#TODO: Debug Strassen's matrix multiplication
class Matrix:
    "An implementation of the mathematical structure of a matrix"

    def __init__(self: 'Matrix', num_rows=1, num_columns=1, data=None) -> None:
        """
        Initialize a num_rows by num_columns matrix object, optionally populated with elements from the data paramater,
        which is a list of lists where each inner list represents a 

        >>> x = Matrix(2, 3)
        >>> x.dim()[0] == 2
        True
        >>> x.dim()[1] == 3
        True
        """

        self.matrix_body = LList()
        for row in range(num_rows):
            self.matrix_body.append(LList())
            for column in range(num_columns):
                self.matrix_body[row].append(0)
            

    #The representation is correct, but using print on str turns the parameter back into its original data type
    #This violates the specified type contract of the function. Fix this somehow
    def __repr__(self: 'Matrix') -> str:
        """
        Return a strng representation of the current Matrix object

        >>> x = Matrix(2, 2)
        >>> x.setitem(0, 0, 1)
        >>> x.setitem(0, 1, 3)
        >>> x.setitem(1, 0, 4)
        >>> x.setitem(1, 1, 5)
        """

        matrix_string = ""
        for row in range(len(self.matrix_body)):
            matrix_string = matrix_string + str(self.matrix_body[row]) + "\n"
        return matrix_string

    def __eq__(self: 'Matrix', other: 'Matrix') -> bool:
        """
        Return True iff each element the current matrix and other are equal"

        >>> x = Matrix(2, 2)
        >>> x.setitem(0, 0, 1)
        >>> x.setitem(0, 1, 3)
        >>> x.setitem(1, 0, 4)
        >>> x.setitem(1, 1, 5)
        >>> y = Matrix(2, 2)
        >>> y.setitem(0, 0, 1)
        >>> y.setitem(0, 1, 3)
        >>> y.setitem(1, 0, 4)
        >>> y.setitem(1, 1, 5)
        >>> x == y
        True
        >>> z = Matrix()
        >>> x == z
        False
        """

        if not isinstance(other, Matrix):
            return False
        elif len(self.matrix_body) != len(other.matrix_body) or len(self.matrix_body[0]) != len(other.matrix_body[0]):
            return False
        else:
            for i in range(len(self.matrix_body)):
                for j in range(len(self.matrix_body[0])):
                    if self.matrix_body[i][j] != other.matrix_body[i][j]:
                        return False
        return True

    def dim(self: 'Matrix') -> 'LList of (int, int)':
        """
        Return the dimensions of the current matrix, in the form of [row, columns]"

        >>> x = Matrix(2, 3)
        >>> x.setitem(0, 0, 1)
        >>> x.setitem(0, 1, 3)
        >>> x.setitem(1, 0, 4)
        >>> x.setitem(1, 1, 5)
        >>> x.dim()[0] == 2
        True
        >>> x.dim()[1] == 3
        True
        """

        row_length = len(self.matrix_body)
        column_length = len(self.matrix_body[0])  

        result_list = LList()
        result_list.append(row_length)
        result_list.append(column_length)
        
        return result_list

    def __add__(self: 'Matrix', other: 'Matrix') -> 'Matrix':
        """Return the sum of the current matrix and other

        >>> x = Matrix(2, 2)
        >>> x.setitem(0, 0, 1)
        >>> x.setitem(0, 1, 3)
        >>> x.setitem(1, 0, 4)
        >>> x.setitem(1, 1, 5)
        >>> y = Matrix(2, 2)
        >>> y.setitem(0, 0, 2)
        >>> y.setitem(0, 1, 2)
        >>> y.setitem(1, 0, 1)
        >>> y.setitem(1, 1, 2)
        >>> z = x + y
        >>> a = Matrix(2, 2)
        >>> a.setitem(0, 0, 3)
        >>> a.setitem(0, 1, 5)
        >>> a.setitem(1, 0, 5)
        >>> a.setitem(1, 1, 7)
        >>> a == z
        True
        """

        self_matrix_dimensions = self.dim()
        other_matrix_dimensions = other.dim()

        if self_matrix_dimensions[0] != other_matrix_dimensions[0] or self_matrix_dimensions[1] != other_matrix_dimensions[1]:
            raise IndexError("The input matrices are not of equal size!")
        else:
            matrix_sum = Matrix(self_matrix_dimensions[0], self_matrix_dimensions[1])
            for i in range(self_matrix_dimensions[0]):
                for j in range(self_matrix_dimensions[0]):
                    if isinstance(self.matrix_body[i][j], (int, float)) and isinstance(other.matrix_body[i][j], (int, float)):
                        matrix_sum.setitem(i, j, self.matrix_body[i][j] + other.matrix_body[i][j])
                    else:
                        raise TypeError("One of the elements in the input matrices is not a number!")
            return matrix_sum

    def __sub__(self: 'Matrix', other: 'Matrix') -> 'Matrix':
        """
        Return the difference of the current matrix and other

        >>> x = Matrix(2, 2)
        >>> x.setitem(0, 0, 1)
        >>> x.setitem(0, 1, 3)
        >>> x.setitem(1, 0, 4)
        >>> x.setitem(1, 1, 5)
        >>> y = Matrix(2, 2)
        >>> y.setitem(0, 0, 2)
        >>> y.setitem(0, 1, 2)
        >>> y.setitem(1, 0, 1)
        >>> y.setitem(1, 1, 2)
        >>> z = x - y
        >>> a = Matrix(2, 2)
        >>> a.setitem(0, 0, -1)
        >>> a.setitem(0, 1, 1)
        >>> a.setitem(1, 0, 3)
        >>> a.setitem(1, 1, 3)
        >>> a == z
        True
        """

        self_matrix_dimensions = self.dim()
        other_matrix_dimensions = other.dim()

        if self_matrix_dimensions[0] != other_matrix_dimensions[0] or self_matrix_dimensions[1] != other_matrix_dimensions[1]:
            raise IndexError("The input matrices are not of equal size!")
        else:
            matrix_difference = Matrix(self_matrix_dimensions[0], self_matrix_dimensions[1])
            for i in range(self_matrix_dimensions[0]):
                for j in range(self_matrix_dimensions[0]):
                    if isinstance(self.matrix_body[i][j], (int, float)) and isinstance(other.matrix_body[i][j], (int, float)):
                        matrix_difference.setitem(i, j, self.matrix_body[i][j] - other.matrix_body[i][j])
                    else:
                        raise TypeError("One of the elements in the input matrices is not a number!")
            return matrix_difference

    def __mul__(self: 'Matrix', other: 'Num or Matrix') -> 'Matrix':
        """
        Return the product of the current matrix times other

        >>> x = Matrix(2, 2)
        >>> x.setitem(0, 0, 1)
        >>> x.setitem(0, 1, 3)
        >>> x.setitem(1, 0, 4)
        >>> x.setitem(1, 1, 5)
        >>> y = Matrix(2, 2)
        >>> y.setitem(0, 0, 2)
        >>> y.setitem(0, 1, 2)
        >>> y.setitem(1, 0, 1)
        >>> y.setitem(1, 1, 2)
        >>> a = Matrix(2, 2)
        >>> a.setitem(0, 0, 5)
        >>> a.setitem(0, 1, 8)
        >>> a.setitem(1, 0, 13)
        >>> a.setitem(1, 1, 18)
        >>> z = x * y
        >>> z == a
        True
        """

        if isinstance(other, int) or isinstance(other, float):
            matrix_product = Matrix(self.dim()[0], self.dim()[1])
            for row in range(self.dim()[0]):
                for column in range(self.dim()[1]):
                    matrix_product.setitem(row, column, self.getitem(row, column) * other)
            return matrix_product
        #Base Case: For matrices of this size, the ratio of speed gains to overhead due to using Strassen's Algorithm is not worth using it.
        elif len(self.matrix_body) <= 1:
            if self.dim()[1] != other.dim()[0]:
                raise IndexError("There is a length mismatch between one of the columns in the first matrix and a row in the second!!!")
            else:
                rows = other.dim()[0]
                columns = self.dim()[1]
                matrix_product = Matrix(self.dim()[0], other.dim()[1])
                for i in range(rows):
                    for j in range(columns):
                        current_dot_product = LList()
                        for k in range(rows):
                            if isinstance(self.matrix_body[i][k], (int, float)) and isinstance(other.matrix_body[k][j], (int, float)):
                                current_dot_product.append(self.matrix_body[i][k] * other.matrix_body[k][j])
                                matrix_product.setitem(i, j, sum(current_dot_product))
                            else:
                                raise TypeError("One of the elements in the input matrices is not a number!")
                return matrix_product
        #Recursive Case: Strassen's Algorithm
        else:
            #Store the dimensions of the matrices
            x_matrix_size = x.dim()
            y_matrix_size = y.dim()

            #Pad the matrices to make them square
            if x_matrix_size[0] % 2 != 0:
                new_row = LList()
                for column in range(x_matrix_size[1]):
                    new_row.append(0)
                x.matrix_body.append(new_row)
            elif x_matrix_size[1] % 2 != 0:
                for row in range(x_matrix_size[0]):
                    x.matrix_body[row].append(0)

            if y_matrix_size[0] % 2 != 0:
                new_row = LList()
                for column in range(y_matrix_size[1]):
                    new_row.append(0)
                y.matrix_body.append(new_row)
            elif y_matrix_size[1] % 2 != 0:
                for row in range(y_matrix_size[0]):
                    y.matrix_body[row].append(0)

            #Partition the matrices into four submatrices
            x_top_left = Matrix()
            x_top_left.matrix_body = x.matrix_body[0:x_matrix_size[0] // 2]
            print('xtop left body')
            print(x_top_left.matrix_body)
            for column in range(len(x_top_left.matrix_body)):
                x_top_left.matrix_body[column] = x_top_left.matrix_body[column][0:x_matrix_size[1] // 2]
            print(x_top_left)

            x_bottom_left = Matrix()
            x_bottom_left.matrix_body = x.matrix_body[x_matrix_size[0] // 2:]
            print('xbottom left body')
            print(x_bottom_left.matrix_body)
            for column in range(len(x_bottom_left.matrix_body)):
                x_bottom_left.matrix_body[column] = x_bottom_left.matrix_body[column][0:x_matrix_size[1] // 2]
            print(x_bottom_left)

            x_top_right = Matrix()
            x_top_right.matrix_body = x.matrix_body[0:x_matrix_size[0] // 2]
            print('x top right body')
            print(x_top_right.matrix_body)
            for column in range(len(x_top_right.matrix_body)):
                x_top_right.matrix_body[column] = x_top_right.matrix_body[column][x_matrix_size[1] // 2:x_matrix_size[1]] 

            print(x_top_right)

            x_bottom_right = Matrix()
            x_bottom_right.matrix_body = x.matrix_body[x_matrix_size[0] // 2:]
            print('x bottom right body')
            print(x_bottom_right.matrix_body)
            for column in range(len(x_bottom_right.matrix_body)):
                x_bottom_right.matrix_body[column] = x_bottom_right.matrix_body[column][x_matrix_size[1] // 2:x_matrix_size[1]]

            print(x_bottom_right)

            y_top_left = Matrix()
            y_top_left.matrix_body = y.matrix_body[0:y_matrix_size[0] // 2]
            print('top left body')
            print(y_top_left.matrix_body)
            for column in range(len(y_top_left.matrix_body)):
                y_top_left.matrix_body[column] = y_top_left.matrix_body[column][0:y_matrix_size[1] // 2]
            print(y_top_left)

            y_bottom_left = Matrix()
            y_bottom_left.matrix_body = y.matrix_body[y_matrix_size[0] // 2:]
            print('bottom left body')
            print(y_bottom_left.matrix_body)
            for column in range(len(y_bottom_left.matrix_body)):
                y_bottom_left.matrix_body[column] = y_bottom_left.matrix_body[column][0:y_matrix_size[1] // 2]
            print(y_bottom_left)

            y_top_right = Matrix()
            y_top_right.matrix_body = y.matrix_body[0:y_matrix_size[0] // 2]
            print('y top right body')
            print(y_top_right.matrix_body)
            for column in range(len(y_top_right.matrix_body)):
                y_top_right.matrix_body[column] = y_top_right.matrix_body[column][y_matrix_size[1] // 2:y_matrix_size[1]] 

            print(y_top_right)

            y_bottom_right = Matrix()
            y_bottom_right.matrix_body = y.matrix_body[y_matrix_size[0] // 2:]
            print('y bottom right body')
            print(y_bottom_right.matrix_body)
            for column in range(len(y_bottom_right.matrix_body)):
                y_bottom_right.matrix_body[column] = y_bottom_right.matrix_body[column][y_matrix_size[1] // 2:y_matrix_size[1]]
            print(y_bottom_right)

            #Recursively compute Strassen's seven products 
            p1 =  x_top_left * (y_top_right - y_bottom_right)
            p2 = (x_top_left + x_top_right) * y_bottom_right
            p3 = (x_bottom_left + x_bottom_right) * y_top_left
            p4 =  x_bottom_right * (y_bottom_left - y_top_left)
            p5 = (x_top_left + x_bottom_right) * (y_top_left + y_bottom_right)
            p6 = (x_top_right - x_bottom_right) * (y_bottom_left + y_bottom_right)
            p7 = (x_top_left - x_bottom_left) * (y_top_left + y_top_right)

            #Compute the matrix quadrants using the above products
            top_left = p5 + p4 - p2 + p6
            bottom_left = p3 + p4
            top_right = p1 + p2
            print('products for bottom')
            print(p1)
            print(p5)
            print(p3)
            print(p2)
            bottom_right = p1 + p5 - p3 - p7
            print('bottom')
            print(bottom_right)
            #Combine the above quadrants into the final matrix and return it
            top_left.matrix_body.extend(bottom_left.matrix_body)
            top_right.matrix_body.extend(bottom_right.matrix_body)
            for i in range(top_left.dim()[0]):
                top_left.matrix_body[i].extend(top_right.matrix_body[i])
            #print(top_left)
            return top_left

    def __contains__(self: 'Matrix', value: 'num') -> bool:
        """
        Return True iff value is present within the current matrix

        >>> x = Matrix(2, 2)
        >>> x.setitem(0, 0, 1)
        >>> x.setitem(0, 1, 3)
        >>> x.setitem(1, 0, 4)
        >>> x.setitem(1, 1, 5)
        >>> 5 in x
        True
        >>> 100 in x
        False
        """

        for row in self.matrix_body:
            if value in row:
                return True
        return False

    def getitem(self: 'Matrix', row: int, column: int):
        """
        Return the value at row row and column column within the current matrix

        >>> x = Matrix(2, 2)
        >>> x.setitem(0, 0, 1)
        >>> x.setitem(0, 1, 3)
        >>> x.setitem(1, 0, 4)
        >>> x.setitem(1, 1, 5)
        >>> x.getitem(1, 0) == 4
        True
        """

        return self.matrix_body[row][column]

    def setitem(self: 'Matrix', row: int, column: int, value: 'num') -> None:
        """
        Set the value of the matrix at the position defined by row and column equal to value

        >>> x = Matrix(2, 2)
        >>> x.setitem(0, 0, 1)
        >>> x.setitem(0, 1, 3)
        >>> x.setitem(1, 0, 4)
        >>> x.setitem(1, 1, 5)
        >>> x.matrix_body[0][0] == 1
        True
        """

        self.matrix_body[row][column] = value

<<<<<<< HEAD
##Priority_Queue##

class Priority_Node(Node):
    """A node element for a priority queue"""

    def __init__(self: 'Priority_Node', value: 'object', priority: int):
        "Initialize a new priority node with value value and priority priority"

        super().__init__(value)
        self.priority = priority

    def __repr__(self: 'Priority_Node'):
        "Return a string representation of the current priority node"

        return "Node(" + str(self.value) + ") Priority: " + str(self.priority)

    def set_priority(self: "Priority_Node", priority: int):
        "Set the priority of the current node to priority"

        self.priority = priority

    def get_priority():
        "Return the priority of the current node"

        return self.priority
        

#Ideally, we would want a key or index to access a given element in constant time so that we may alter an elements priority without having to search through the heap body
#Question: Why do we bother with a heap when a dictionary with a key of max will alos provide the ax of the heap in constant time?
#Answer: Not only does the heap provide constant time access to the max, but it PRESERVES CONSTANT TIME ACCESS IN LOGARITHMIC TIME. A dictionary would need to do a linear search to find the new max after extracting it, or adding items.

#TODO: Make sure al the operations invlovling lenght are correct due to the heap index being 1 based
#TODO: TEST ABD DEBUG
class Priority_Queue:
    """An implementation of the prority_queue ADT using a max heap"""

    def __init__(self: 'Priority_Queue', data = []):
        "Initialize a priority queue with elements composed of data"
        
        self.body = data
        for i in range(len(self.body)):
            self.body[i] = Priority_Node(self.body[i], 0)
        self.body.insert(0, len(data))

        #Heapify
        for i in range(len(self.body) // 2, 1, 1):
            bubble_down(i)

    def __str__(self: 'Priority_Queue'):
        "Return a string representation of the current priority queue"
        #TODO: Implement this
        pass

    def __len__(self: 'Priority_Queue'):
        "Return the number of elements in the queue"

        return self.body[0]

    def is_empty(self:"Priority_Queue"):
        "Return true iff the current priority queue has 0 elements"

        return self.body[0] == 0
        
    def peek_max(self: 'Priority_Queue'):
        "Return the element with the highest priority in the queue or false if empty"

        if self.is_empty() == False:
            return self.body[1]
        else:
            return False

    def bubble_down(self: "Priority_Queue", index: int):
        "Restore the heap property by bubbling the element stored at index down the heap"

        #Base Case: The current sub heap has no children
        if 2 * index >= len(self.body):
            pass
        #The current sub heap has a left child but no right child
        elif 2 * index == len(self.body) - 1:
            cur_element = self.body[index]
            left_child = self.body[2 * index]
            self.body[index] = left_child
            self.body[2 * index] = cur_element
            self.bubble_down(2 * index)
        #The current sub heap has two children
        else:
            cur_element = self.body[index]
            left_child = self.body[2 * index]
            right_child = self.body[2 * index + 1]
            if left_child.get_priority() >= right_child.get_priority():
                self.body[index] = left_child
                self.body[2 * index] = cur_element
                self.bubble_down(2 * index)
            else:
                self.body[index] = right_child
                self.body[2 * index + 1] = cur_element
                self.bubble_down(2 * index + 1)

    def bubble_up(index):
        if self.body[index] > self.body[index // 2]:
            parent_node = self.body[index // 2]
            self.body[index // 2] = self.body[index]
            self.body[index] = parent_node
            self.bubble_up(index // 2)
        

    def extract_max(self: 'Heap'):
        "Remove and return the element with the highest priority in the queue otherwise false if empty"
        if self.is_empty() == False:

            #Swap the first and last elements and decrement the array
            max_element = self.body[1]
            self.body[1] = self.body[len(self.body)- 1]
            self.pop()

            #Update the size counter
            self.body[0] -= 1

            #Bubble down the new first element to maintain the heap property
            self.bubble_down(1)
            return max_element
        else:
            return False
        
    def insert(self: 'Priority_Queue', element: 'object', priority = 0):
        "Insert element element into the current priority queue with priority priority"

        new_node = Priority_Node(element, priority)
        self.body.append(new_node)
        self.bubble_up(len(self.body) - 1)

    def set_priority(self: 'Priority_Queue', index: int, priority: int):
        "set the prioruty of the element at index index to priority priority"

        if self.body[index].get_priority() > priority:
            self.bubble_down(index)
            self.body[index].set_priority(priority)
        elif self.body[index].get_priority() < priority:
            self.bubble_up(index)
            self.body[index].set_priority(priority)


class BST_Node(Node):
    "A Node for a binary search tree"

    def __init__(self: 'BST_Node', key: 'object', value: 'object', parent = None, left_child = None, right_child= None):
        "Initialize a new binary search tree node with the given parameters"

        super().__init__(value)
        self.key = key

    def __repr__(self: 'BST_Node'):
        "Return a string representation of the current binary search tree node"

        return "BST_Node(key: " + str(self.key) + " value: " + str(self.value)
    
    def get_value(self: "BST_Node"):
        "Return the value stored in the current BST_Node"

        return self.value

    def set_value(self: 'BST_Node', value: 'object'):
        "Set the value of the current node"

        self.value = value

    def get_key(self: 'BST_Node'):
        "Return the key of the current BST_Node"

        return self.key

    def set_key(self: "BST_Node", key: 'object'):
        "Set the key of the current BST_Node"

        self.key = key

class Binary_Search_Tree():
    "A Binary Search Tree"

    def __init__(self: 'Binary_Search_Tree', root: 'BST_Node', parent: 'Binary_Search_Tree', left_child: 'Binary_Search_Tree', right_child: 'Binary_SEarch_Tree'):
        "Initialize a new Binary Search Tree"

        self.root = root
        self.parent = parent
        self.left_child = left_child
        self.right_child = right_child

    def __repr__(self: "Binary_Search_Tree"):
        "Return a string representation of the current binary search tree"

        pass

    def get_root(self: 'Binary_Search_Tree'):
        "Return the root node of the current binary search tree"

        return self.root

    def set_root(self: 'Binary_Search_Tree', new_root: "BST_Node"):
        "Set the root node of the current binary search tree"

        self.root = new_root

    def get_parent(self: 'Binary_Search_Tree'):
        "Return the parent of the current BST_Node"

        return self.parent

    def set_parent(self: 'Binary_Search_Tree', parent: 'Binary_Search_Tree'):
        "Set the parent of the current BST_Node"

        self.parent = parent

    def get_left_child(self: 'Binary_Search_Tree'):
        "Return the left child of the current BST_Node"

        return self.left_child

    def set_left_child(self: 'Binary_Search_Tree', left_child: 'Binary_Search_Tree'):
        "Set the left child of the current BST_Node to left_child"

        self.left_child = left_child

    def get_right_child(self: 'Binary_Search_Tree'):
        "Return the right child of the current Binary_Search_Tree"

        self.right_child

    def set_right_child(self: 'Binary_Search_Tree', right_child: 'Binary_Search_Tree'):
        "Set the right child of the current Binary_Search_Tree to right_child"

        self.right_child = right_child

    def get_keys(self: 'Binary_Sarch_Tree'):
        "Return the keys of the current binary search tree in sorted order"

        if self.get_root() != None:
            self.get_left_child().get_keys()
            print(self.get_root().get_key())
            self.get_right_child().get_keys()

    def search(self: 'Binary_Search_Tree', key: object):
        "Find and return the node associated with key key, if present. Otherwise, return false"

        key_node = self.traverse_to_key(key)
        if key_node != None:
            return key_node.get_root().get_value()
        else:
            return False

    def minimum(self: 'Binary_Search_Tree'):
        "Return the minimum of the current binary search tree, or None if no minimum is found"

        if self.get_root() == None:
            return None
        else:
            cur_node = self
            while cur_node != None:
                cur_node = self.get_left_child()
            return cur_node.get_root().get_key()

    def maximum(self: 'Binary_Search_Tree'):
        "Return the maimum of the current binary search tree, or None if no maximum is found"

        if self.get_root() == None:
            return None
        else:
            cur_node = self
            while cur_node != None:
                cur_node = self.get_right_child()
            return cur_node.get_root().get_key()

    def successor(self: 'Binary_Search_Tree', key: object):
        "Return the successor, according to an inorder traversal, of the node at key key, if present, otherwise return None"

        key_node = self.traverse_to_key(key)
        if key_node == None:
            return None
        elif key_node.get_right_child() != None:
            return self.get_right_child().minimum()
        else:
            while key_node != None and cur_node != cur_node.get_parent().get_left_child():
                cur_node = cur_node.get_parent()
            return cur_node

    #def predecessor():
        

    def traverse_to_key(self: 'Binary_Search_Tree', key: object):
        "Traverse to the position in the current binary search tree denoted by key, if it exists, else return None"

        if self.get_root() == None:
            return None
        elif self.get_root().get_key() == key:
            return self
        elif self.get_root().get_key() < key:
            self.get_left_child().traverse_to_key(key)
        else:
            self.get_right_child().traverse_to_key(key)

    def insert(self: 'Binary_Search_Tree', key: object, value: object):
        "Insert value with key in the current binary search tree"

        if self.get_root() == None or self.get_root().get_key() == key:
            self.get_root().set_key(key)
            self.get_root().set_value(value)
        elif key < self.get_root().get_key():
            self.get_left_child().insert(key, value)
        else:
            self.get_right_child().insert(key, value)
            

    #TO DO Implement this
    def delete(self: "Binar_Search_Tree", key: object):
        "Delete the node indexed at position k"
        

##REALLY ROUGH RANDOM TESTING##
##TO DO: Improve

print("Build A Graph for testing")
x = Graph()

#First Connected Component
x.add_node(1)
x.add_node(2, 1)
x.add_node(3, 1)
x.add_node(4, 1)
x.add_node(5, 2)
x.add_node(6, 2)
x.add_node(7, 2)
x.add_node(8, 4)
x.add_node(9, 5)
x.add_node(10, 5)
x.add_node(11, 6)
x.add_node(12, 7)
x.add_edge(10, 11)
x.add_edge(11, 8)
x.add_edge(2, 3)
x.add_edge(12, 10)

#SEcond Connected Component
x.add_node(13)
x.add_node(14, 13)
x.add_node(15, 13)
x.add_edge(14, 15)
x.add_node(16, 15)

#Third Connected Component
x.add_node(17)

##print("Build a matrix for testing")
##x = Matrix(2, 2)
##x.setitem(0, 0, 1)
##x.setitem(0, 1, 3)
##x.setitem(1, 0, 4)
##x.setitem(1, 1, 5)
##
##y = Matrix(2, 2)
##y.setitem(0, 0, 2)
##y.setitem(0, 1, 2)
##y.setitem(1, 0, 1)
##y.setitem(1, 1, 2)
##
##a = Matrix(2, 2)
##a.setitem(0, 0, 5)
##a.setitem(0, 1, 8)
##a.setitem(1, 0, 13)
##a.setitem(1, 1, 18)
##
##print("Run the matrix tests")
##z = x * y
##print(z == a)
=======
##REALLY ROUGH TESTING##
##TO DO: Improve

print("Build A Graph for testing")
x = Graph(1)
x.add_node(1, 2)
x.add_node(1, 3)
x.add_node(1, 4)
x.add_node(2, 5)
x.add_node(2, 6)
x.add_node(4, 7)
x.add_node(4, 8)
x.add_node(5, 9)
x.add_node(5, 10)
x.add_node(7, 11)
x.add_node(7, 12)

print("Run the graph tests")
#Shortest_Num_Steps(x, 1, 11)

print("Build a matrix for testing")
x = Matrix(2, 2)
x.setitem(0, 0, 1)
x.setitem(0, 1, 3)
x.setitem(1, 0, 4)
x.setitem(1, 1, 5)

y = Matrix(2, 2)
y.setitem(0, 0, 2)
y.setitem(0, 1, 2)
y.setitem(1, 0, 1)
y.setitem(1, 1, 2)

a = Matrix(2, 2)
a.setitem(0, 0, 5)
a.setitem(0, 1, 8)
a.setitem(1, 0, 13)
a.setitem(1, 1, 18)

print("Run the matrix tests")
z = x * y
print(z == a)
>>>>>>> 065814e8b6dfd54a9fe3d6ee12331e28e75be793
